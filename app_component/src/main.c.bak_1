
/*
 * imageIpTest.c
 *
 *  Created on: Apr 4, 2020
 *      Author: VIPIN
 */

#include "xaxidma.h"
#include "xparameters.h"
#include "sleep.h"
#include "xil_cache.h"
#include "xil_io.h"
#include "xscugic.h"
#include "test_sample.h"
#include "xuartps.h"

#ifndef DDR_BASE_ADDR
#warning CHECK FOR THE VALID DDR ADDRESS IN XPARAMETERS.H, \
DEFAULT SET TO 0x01000000
#define MEM_BASE_ADDR		0x01000000
#else
#define MEM_BASE_ADDR		(DDR_BASE_ADDR + 0x1000000)
#endif

#define TX_BUFFER_BASE		(MEM_BASE_ADDR + 0x00100000)
#define RX_BUFFER_BASE		(MEM_BASE_ADDR + 0x00300000)
#define RX_BUFFER_HIGH		(MEM_BASE_ADDR + 0x004FFFFF)

#define imageSize 512*512

u32 checkHalted(u32 baseAddress,u32 offset);

XScuGic IntcInstance;
static void imageProcISR(void *CallBackRef);
static void dmaReceiveISR(void *CallBackRef);
int done;
__attribute__((aligned(32))) u32 out_buffer[97*97*4] = {0};

typedef enum {
    NET_CONFIG_CNN,
    NET_CONFIG_MAXPOOLING
} NET_CONFIG;

typedef struct NET_IP__data_{
    int height;
    int width;
    u32* inputData;
    u32* processedData;
    int  processed_count;
    NET_CONFIG config
}NET_IP__data;

int NET_IP_dma_reset(){
    // reset the dma
}

int NET_IP__init(){
    // verify chip id
    // 
}

int NET_IP__setup_cnn(){

}

int NET_IP__setup_maxpooling(){
    
}

int NET_IP__get_row_count(){

}

int NET_IP__section_process(u32* inputPtr, int in_length, u32* outputPtr, int out_length){
    //
}

int NET_IP__setup_intr(){

}

static void NET_IP__dma_sent_intr(){

}

static void NET_IP__dma_receive_intr(){

}

static void NET_IP__row_completed_intr(){
    
}

int main(){
    u32 status;
	u32 totalTransmittedBytes=0;
	u32 transmittedBytes = 0;
	XUartPs_Config *myUartConfig;
	XUartPs myUart;

	// Initialize uart
	myUartConfig = XUartPs_LookupConfig(XPAR_UART1_BASEADDR);
	status = XUartPs_CfgInitialize(&myUart, myUartConfig, myUartConfig->BaseAddress);
	if(status != XST_SUCCESS)
		print("Uart initialization failed...\n\r");
	status = XUartPs_SetBaudRate(&myUart, 115200);
	if(status != XST_SUCCESS)
		print("Baudrate init failed....\n\r");

	XAxiDma_Config *myDmaConfig;
	XAxiDma myDma;
    u32* RxBufferPtr;
    RxBufferPtr = (u32*) RX_BUFFER_BASE;

    //DMA Controller Configuration
	myDmaConfig = XAxiDma_LookupConfig(XPAR_AXI_DMA_0_BASEADDR);
	status = XAxiDma_CfgInitialize(&myDma, myDmaConfig);
	if(status != XST_SUCCESS){
		print("DMA initialization failed\n");
		return -1;
	}

	XAxiDma_IntrEnable(&myDma, XAXIDMA_IRQ_IOC_MASK, XAXIDMA_DEVICE_TO_DMA);

	//Interrupt Controller Configuration
	XScuGic_Config *IntcConfig;
    
	IntcConfig = XScuGic_LookupConfig(XPAR_XSCUGIC_0_BASEADDR);
	status =  XScuGic_CfgInitialize(&IntcInstance, IntcConfig, IntcConfig->CpuBaseAddress);

	if(status != XST_SUCCESS){
		xil_printf("Interrupt controller initialization failed..");
		return -1;
	}

	XScuGic_SetPriorityTriggerType(&IntcInstance,XPS_FPGA2_INT_ID,0xA0,3);
	status = XScuGic_Connect(&IntcInstance,XPS_FPGA2_INT_ID,(Xil_InterruptHandler)imageProcISR,(void *)&myDma);
	if(status != XST_SUCCESS){
		xil_printf("Interrupt connection failed");
		return -1;
	}
	XScuGic_Enable(&IntcInstance,XPS_FPGA2_INT_ID);

	XScuGic_SetPriorityTriggerType(&IntcInstance,XPS_FPGA1_INT_ID,0xA1,3);
	status = XScuGic_Connect(&IntcInstance,XPS_FPGA1_INT_ID,(Xil_InterruptHandler)dmaReceiveISR,(void *)&myDma);
	if(status != XST_SUCCESS){
		xil_printf("Interrupt connection failed");
		return -1;
	}
	XScuGic_Enable(&IntcInstance,XPS_FPGA1_INT_ID);

	Xil_ExceptionInit();
	Xil_ExceptionRegisterHandler(XIL_EXCEPTION_ID_INT,(Xil_ExceptionHandler)XScuGic_InterruptHandler,(void *)&IntcInstance);
	Xil_ExceptionEnable();

    Xil_DCacheFlushRange((UINTPTR)out_buffer, 97*100*4);

	status = XAxiDma_SimpleTransfer(&myDma,(u32)out_buffer, 97*40*4,XAXIDMA_DEVICE_TO_DMA);
    u32 dma_status;
    dma_status = XAxiDma_ReadReg(myDma.RegBase, XAXIDMA_SR_OFFSET);
    xil_printf("DMA status: 0x%x\r\n", dma_status);
	status = XAxiDma_SimpleTransfer(&myDma,(u32)imageData, 4*100*4,XAXIDMA_DMA_TO_DEVICE);//typecasting in C/C++
	if(status != XST_SUCCESS){
		print("DMA initialization failed\n");
		return -1;
	}


    while(!done){

    }


	// while(totalTransmittedBytes < imageSize){
		transmittedBytes =  XUartPs_Send(&myUart,(u8*)&imageData[totalTransmittedBytes],1);
		// totalTransmittedBytes += transmittedBytes;
	// 	usleep(1000);
	// }
    xil_printf("done\n");

}


u32 checkIdle(u32 baseAddress,u32 offset){
	u32 status;
	status = (XAxiDma_ReadReg(baseAddress,offset))&XAXIDMA_IDLE_MASK;
	return status;
}


static void imageProcISR(void *CallBackRef){
	static int i=4;
	int status;
    xil_printf("imageProcISR %d\n", i);
    xil_printf("\tReg Status -  %04x\n", Xil_In32(XPAR_NET_ENGINE_0_BASEADDR + (2*4)));
	XScuGic_Disable(&IntcInstance,XPS_FPGA2_INT_ID);
	// status = checkIdle(XPAR_AXI_DMA_0_BASEADDR,0x4);
	// while(status == 0)
	// 	status = checkIdle(XPAR_AXI_DMA_0_BASEADDR,0x4);
	if(i<514){
        // status = XAxiDma_SimpleTransfer((XAxiDma *)CallBackRef,(u32)out_buffer, 97*4,XAXIDMA_DEVICE_TO_DMA);
		status = XAxiDma_SimpleTransfer((XAxiDma *)CallBackRef,(u32)&imageData[i*100],100 * 4,XAXIDMA_DMA_TO_DEVICE);
		i++;
	}
	XScuGic_Enable(&IntcInstance,XPS_FPGA2_INT_ID);
}


static void dmaReceiveISR(void *CallBackRef){
	XAxiDma_IntrDisable((XAxiDma *)CallBackRef, XAXIDMA_IRQ_IOC_MASK, XAXIDMA_DEVICE_TO_DMA);
	XAxiDma_IntrAckIrq((XAxiDma *)CallBackRef, XAXIDMA_IRQ_IOC_MASK, XAXIDMA_DEVICE_TO_DMA);
	// done = 1;
    xil_printf("dmaReceiveISR\n");
	XAxiDma_IntrEnable((XAxiDma *)CallBackRef, XAXIDMA_IRQ_IOC_MASK, XAXIDMA_DEVICE_TO_DMA);
}



